// Code generated by protoc-gen-go. DO NOT EDIT.
// source: wanikani.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	wanikani.proto

It has these top-level messages:
	Meaning
	Reading
	Radical
	Kanji
	Vocab
	Subject
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Reading_Type int32

const (
	Reading_ONYOMI  Reading_Type = 1
	Reading_KUNYOMI Reading_Type = 2
	Reading_NANORI  Reading_Type = 3
)

var Reading_Type_name = map[int32]string{
	1: "ONYOMI",
	2: "KUNYOMI",
	3: "NANORI",
}
var Reading_Type_value = map[string]int32{
	"ONYOMI":  1,
	"KUNYOMI": 2,
	"NANORI":  3,
}

func (x Reading_Type) Enum() *Reading_Type {
	p := new(Reading_Type)
	*p = x
	return p
}
func (x Reading_Type) String() string {
	return proto1.EnumName(Reading_Type_name, int32(x))
}
func (x *Reading_Type) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Reading_Type_value, data, "Reading_Type")
	if err != nil {
		return err
	}
	*x = Reading_Type(value)
	return nil
}
func (Reading_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Vocab_PartOfSpeech int32

const (
	Vocab_NOUN              Vocab_PartOfSpeech = 1
	Vocab_NUMERAL           Vocab_PartOfSpeech = 2
	Vocab_INTRANSITIVE_VERB Vocab_PartOfSpeech = 3
	Vocab_ICHIDAN_VERB      Vocab_PartOfSpeech = 4
	Vocab_TRANSITIVE_VERB   Vocab_PartOfSpeech = 5
	Vocab_NO_ADJECTIVE      Vocab_PartOfSpeech = 6
	Vocab_GODAN_VERB        Vocab_PartOfSpeech = 7
	Vocab_NA_ADJECTIVE      Vocab_PartOfSpeech = 8
	Vocab_I_ADJECTIVE       Vocab_PartOfSpeech = 9
	Vocab_SUFFIX            Vocab_PartOfSpeech = 10
	Vocab_ADVERB            Vocab_PartOfSpeech = 11
	Vocab_SURU_VERB         Vocab_PartOfSpeech = 12
	Vocab_PREFIX            Vocab_PartOfSpeech = 13
	Vocab_PROPER_NOUN       Vocab_PartOfSpeech = 14
	Vocab_EXPRESSION        Vocab_PartOfSpeech = 15
	Vocab_ADJECTIVE         Vocab_PartOfSpeech = 16
)

var Vocab_PartOfSpeech_name = map[int32]string{
	1:  "NOUN",
	2:  "NUMERAL",
	3:  "INTRANSITIVE_VERB",
	4:  "ICHIDAN_VERB",
	5:  "TRANSITIVE_VERB",
	6:  "NO_ADJECTIVE",
	7:  "GODAN_VERB",
	8:  "NA_ADJECTIVE",
	9:  "I_ADJECTIVE",
	10: "SUFFIX",
	11: "ADVERB",
	12: "SURU_VERB",
	13: "PREFIX",
	14: "PROPER_NOUN",
	15: "EXPRESSION",
	16: "ADJECTIVE",
}
var Vocab_PartOfSpeech_value = map[string]int32{
	"NOUN":              1,
	"NUMERAL":           2,
	"INTRANSITIVE_VERB": 3,
	"ICHIDAN_VERB":      4,
	"TRANSITIVE_VERB":   5,
	"NO_ADJECTIVE":      6,
	"GODAN_VERB":        7,
	"NA_ADJECTIVE":      8,
	"I_ADJECTIVE":       9,
	"SUFFIX":            10,
	"ADVERB":            11,
	"SURU_VERB":         12,
	"PREFIX":            13,
	"PROPER_NOUN":       14,
	"EXPRESSION":        15,
	"ADJECTIVE":         16,
}

func (x Vocab_PartOfSpeech) Enum() *Vocab_PartOfSpeech {
	p := new(Vocab_PartOfSpeech)
	*p = x
	return p
}
func (x Vocab_PartOfSpeech) String() string {
	return proto1.EnumName(Vocab_PartOfSpeech_name, int32(x))
}
func (x *Vocab_PartOfSpeech) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Vocab_PartOfSpeech_value, data, "Vocab_PartOfSpeech")
	if err != nil {
		return err
	}
	*x = Vocab_PartOfSpeech(value)
	return nil
}
func (Vocab_PartOfSpeech) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type Meaning struct {
	Meaning          *string `protobuf:"bytes,1,opt,name=meaning" json:"meaning,omitempty"`
	IsPrimary        *bool   `protobuf:"varint,2,opt,name=is_primary" json:"is_primary,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Meaning) Reset()                    { *m = Meaning{} }
func (m *Meaning) String() string            { return proto1.CompactTextString(m) }
func (*Meaning) ProtoMessage()               {}
func (*Meaning) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Meaning) GetMeaning() string {
	if m != nil && m.Meaning != nil {
		return *m.Meaning
	}
	return ""
}

func (m *Meaning) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

type Reading struct {
	Reading          *string       `protobuf:"bytes,1,opt,name=reading" json:"reading,omitempty"`
	IsPrimary        *bool         `protobuf:"varint,2,opt,name=is_primary" json:"is_primary,omitempty"`
	Type             *Reading_Type `protobuf:"varint,3,opt,name=type,enum=proto.Reading_Type" json:"type,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Reading) Reset()                    { *m = Reading{} }
func (m *Reading) String() string            { return proto1.CompactTextString(m) }
func (*Reading) ProtoMessage()               {}
func (*Reading) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Reading) GetReading() string {
	if m != nil && m.Reading != nil {
		return *m.Reading
	}
	return ""
}

func (m *Reading) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

func (m *Reading) GetType() Reading_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Reading_ONYOMI
}

type Radical struct {
	Japanese         *string    `protobuf:"bytes,1,opt,name=japanese" json:"japanese,omitempty"`
	Meanings         []*Meaning `protobuf:"bytes,2,rep,name=meanings" json:"meanings,omitempty"`
	CharacterImage   *string    `protobuf:"bytes,3,opt,name=character_image" json:"character_image,omitempty"`
	Mnemonic         *string    `protobuf:"bytes,4,opt,name=mnemonic" json:"mnemonic,omitempty"`
	MeaningNote      *string    `protobuf:"bytes,5,opt,name=meaning_note" json:"meaning_note,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Radical) Reset()                    { *m = Radical{} }
func (m *Radical) String() string            { return proto1.CompactTextString(m) }
func (*Radical) ProtoMessage()               {}
func (*Radical) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Radical) GetJapanese() string {
	if m != nil && m.Japanese != nil {
		return *m.Japanese
	}
	return ""
}

func (m *Radical) GetMeanings() []*Meaning {
	if m != nil {
		return m.Meanings
	}
	return nil
}

func (m *Radical) GetCharacterImage() string {
	if m != nil && m.CharacterImage != nil {
		return *m.CharacterImage
	}
	return ""
}

func (m *Radical) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

func (m *Radical) GetMeaningNote() string {
	if m != nil && m.MeaningNote != nil {
		return *m.MeaningNote
	}
	return ""
}

type Kanji struct {
	Japanese            *string    `protobuf:"bytes,1,opt,name=japanese" json:"japanese,omitempty"`
	Readings            []*Reading `protobuf:"bytes,2,rep,name=readings" json:"readings,omitempty"`
	Meanings            []*Meaning `protobuf:"bytes,3,rep,name=meanings" json:"meanings,omitempty"`
	MeaningMnemonic     *string    `protobuf:"bytes,4,opt,name=meaning_mnemonic" json:"meaning_mnemonic,omitempty"`
	MeaningHint         *string    `protobuf:"bytes,5,opt,name=meaning_hint" json:"meaning_hint,omitempty"`
	ReadingMnemonic     *string    `protobuf:"bytes,6,opt,name=reading_mnemonic" json:"reading_mnemonic,omitempty"`
	ReadingHint         *string    `protobuf:"bytes,7,opt,name=reading_hint" json:"reading_hint,omitempty"`
	ComponentSubjectIds []int32    `protobuf:"varint,8,rep,name=component_subject_ids" json:"component_subject_ids,omitempty"`
	XXX_unrecognized    []byte     `json:"-"`
}

func (m *Kanji) Reset()                    { *m = Kanji{} }
func (m *Kanji) String() string            { return proto1.CompactTextString(m) }
func (*Kanji) ProtoMessage()               {}
func (*Kanji) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Kanji) GetJapanese() string {
	if m != nil && m.Japanese != nil {
		return *m.Japanese
	}
	return ""
}

func (m *Kanji) GetReadings() []*Reading {
	if m != nil {
		return m.Readings
	}
	return nil
}

func (m *Kanji) GetMeanings() []*Meaning {
	if m != nil {
		return m.Meanings
	}
	return nil
}

func (m *Kanji) GetMeaningMnemonic() string {
	if m != nil && m.MeaningMnemonic != nil {
		return *m.MeaningMnemonic
	}
	return ""
}

func (m *Kanji) GetMeaningHint() string {
	if m != nil && m.MeaningHint != nil {
		return *m.MeaningHint
	}
	return ""
}

func (m *Kanji) GetReadingMnemonic() string {
	if m != nil && m.ReadingMnemonic != nil {
		return *m.ReadingMnemonic
	}
	return ""
}

func (m *Kanji) GetReadingHint() string {
	if m != nil && m.ReadingHint != nil {
		return *m.ReadingHint
	}
	return ""
}

func (m *Kanji) GetComponentSubjectIds() []int32 {
	if m != nil {
		return m.ComponentSubjectIds
	}
	return nil
}

type Vocab struct {
	Japanese            *string             `protobuf:"bytes,1,opt,name=japanese" json:"japanese,omitempty"`
	Readings            []*Reading          `protobuf:"bytes,2,rep,name=readings" json:"readings,omitempty"`
	Meanings            []*Meaning          `protobuf:"bytes,3,rep,name=meanings" json:"meanings,omitempty"`
	MeaningExplanation  *string             `protobuf:"bytes,4,opt,name=meaning_explanation" json:"meaning_explanation,omitempty"`
	ReadingExplanation  *string             `protobuf:"bytes,5,opt,name=reading_explanation" json:"reading_explanation,omitempty"`
	Sentences           []*Vocab_Sentence   `protobuf:"bytes,6,rep,name=sentences" json:"sentences,omitempty"`
	ComponentSubjectIds []int32             `protobuf:"varint,7,rep,name=component_subject_ids" json:"component_subject_ids,omitempty"`
	PartOfSpeech        *Vocab_PartOfSpeech `protobuf:"varint,8,opt,name=part_of_speech,enum=proto.Vocab_PartOfSpeech" json:"part_of_speech,omitempty"`
	XXX_unrecognized    []byte              `json:"-"`
}

func (m *Vocab) Reset()                    { *m = Vocab{} }
func (m *Vocab) String() string            { return proto1.CompactTextString(m) }
func (*Vocab) ProtoMessage()               {}
func (*Vocab) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Vocab) GetJapanese() string {
	if m != nil && m.Japanese != nil {
		return *m.Japanese
	}
	return ""
}

func (m *Vocab) GetReadings() []*Reading {
	if m != nil {
		return m.Readings
	}
	return nil
}

func (m *Vocab) GetMeanings() []*Meaning {
	if m != nil {
		return m.Meanings
	}
	return nil
}

func (m *Vocab) GetMeaningExplanation() string {
	if m != nil && m.MeaningExplanation != nil {
		return *m.MeaningExplanation
	}
	return ""
}

func (m *Vocab) GetReadingExplanation() string {
	if m != nil && m.ReadingExplanation != nil {
		return *m.ReadingExplanation
	}
	return ""
}

func (m *Vocab) GetSentences() []*Vocab_Sentence {
	if m != nil {
		return m.Sentences
	}
	return nil
}

func (m *Vocab) GetComponentSubjectIds() []int32 {
	if m != nil {
		return m.ComponentSubjectIds
	}
	return nil
}

func (m *Vocab) GetPartOfSpeech() Vocab_PartOfSpeech {
	if m != nil && m.PartOfSpeech != nil {
		return *m.PartOfSpeech
	}
	return Vocab_NOUN
}

type Vocab_Sentence struct {
	Japanese         *string `protobuf:"bytes,1,opt,name=japanese" json:"japanese,omitempty"`
	English          *string `protobuf:"bytes,2,opt,name=english" json:"english,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Vocab_Sentence) Reset()                    { *m = Vocab_Sentence{} }
func (m *Vocab_Sentence) String() string            { return proto1.CompactTextString(m) }
func (*Vocab_Sentence) ProtoMessage()               {}
func (*Vocab_Sentence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *Vocab_Sentence) GetJapanese() string {
	if m != nil && m.Japanese != nil {
		return *m.Japanese
	}
	return ""
}

func (m *Vocab_Sentence) GetEnglish() string {
	if m != nil && m.English != nil {
		return *m.English
	}
	return ""
}

type Subject struct {
	Id               *int32   `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Level            *int32   `protobuf:"varint,2,opt,name=level" json:"level,omitempty"`
	Slug             *string  `protobuf:"bytes,3,opt,name=slug" json:"slug,omitempty"`
	DocumentUrl      *string  `protobuf:"bytes,4,opt,name=document_url" json:"document_url,omitempty"`
	Radical          *Radical `protobuf:"bytes,5,opt,name=radical" json:"radical,omitempty"`
	Kanji            *Kanji   `protobuf:"bytes,6,opt,name=kanji" json:"kanji,omitempty"`
	Vocab            *Vocab   `protobuf:"bytes,7,opt,name=vocab" json:"vocab,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Subject) Reset()                    { *m = Subject{} }
func (m *Subject) String() string            { return proto1.CompactTextString(m) }
func (*Subject) ProtoMessage()               {}
func (*Subject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Subject) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Subject) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *Subject) GetSlug() string {
	if m != nil && m.Slug != nil {
		return *m.Slug
	}
	return ""
}

func (m *Subject) GetDocumentUrl() string {
	if m != nil && m.DocumentUrl != nil {
		return *m.DocumentUrl
	}
	return ""
}

func (m *Subject) GetRadical() *Radical {
	if m != nil {
		return m.Radical
	}
	return nil
}

func (m *Subject) GetKanji() *Kanji {
	if m != nil {
		return m.Kanji
	}
	return nil
}

func (m *Subject) GetVocab() *Vocab {
	if m != nil {
		return m.Vocab
	}
	return nil
}

func init() {
	proto1.RegisterType((*Meaning)(nil), "proto.Meaning")
	proto1.RegisterType((*Reading)(nil), "proto.Reading")
	proto1.RegisterType((*Radical)(nil), "proto.Radical")
	proto1.RegisterType((*Kanji)(nil), "proto.Kanji")
	proto1.RegisterType((*Vocab)(nil), "proto.Vocab")
	proto1.RegisterType((*Vocab_Sentence)(nil), "proto.Vocab.Sentence")
	proto1.RegisterType((*Subject)(nil), "proto.Subject")
	proto1.RegisterEnum("proto.Reading_Type", Reading_Type_name, Reading_Type_value)
	proto1.RegisterEnum("proto.Vocab_PartOfSpeech", Vocab_PartOfSpeech_name, Vocab_PartOfSpeech_value)
}

func init() { proto1.RegisterFile("wanikani.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 672 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0x55, 0x7e, 0x1c, 0x3b, 0x93, 0x34, 0xf1, 0xb7, 0x69, 0xf5, 0x19, 0x22, 0x44, 0xf0, 0x55,
	0x24, 0x44, 0x24, 0xfa, 0x06, 0xa6, 0x75, 0xc1, 0x94, 0xda, 0x91, 0xdd, 0x54, 0xe5, 0xca, 0xda,
	0x3a, 0xdb, 0x64, 0x5b, 0x7b, 0x6d, 0xd9, 0x4e, 0xa1, 0x37, 0xbc, 0x00, 0x8f, 0xc1, 0x0b, 0xf1,
	0x00, 0x3c, 0x0c, 0xda, 0xf5, 0xba, 0x0d, 0xa5, 0xbd, 0xe4, 0xca, 0x9b, 0x99, 0xb3, 0xe7, 0xcc,
	0x99, 0x9d, 0x09, 0x0c, 0xbe, 0x60, 0x46, 0xaf, 0x31, 0xa3, 0xb3, 0x2c, 0x4f, 0xcb, 0x14, 0x29,
	0xe2, 0x63, 0xce, 0x40, 0x3d, 0x21, 0x98, 0x51, 0xb6, 0x42, 0x43, 0x50, 0x93, 0xea, 0x68, 0x34,
	0x26, 0x8d, 0x69, 0x17, 0x21, 0x00, 0x5a, 0x84, 0x59, 0x4e, 0x13, 0x9c, 0xdf, 0x1a, 0xcd, 0x49,
	0x63, 0xaa, 0x99, 0xdf, 0x40, 0xf5, 0x09, 0x5e, 0x4a, 0x7c, 0x5e, 0x1d, 0x9f, 0xc6, 0xa3, 0x57,
	0xd0, 0x2e, 0x6f, 0x33, 0x62, 0xb4, 0x26, 0x8d, 0xe9, 0x60, 0x7f, 0x54, 0x89, 0xcf, 0x24, 0xc5,
	0xec, 0xf4, 0x36, 0x23, 0xe6, 0x6b, 0x68, 0xf3, 0x2f, 0x02, 0xe8, 0x78, 0xee, 0x67, 0xef, 0xc4,
	0xd1, 0x1b, 0xa8, 0x07, 0xea, 0xf1, 0xa2, 0xfa, 0xd1, 0xe4, 0x09, 0xd7, 0x72, 0x3d, 0xdf, 0xd1,
	0x5b, 0x42, 0x1f, 0x2f, 0x69, 0x84, 0x63, 0xa4, 0x83, 0x76, 0x85, 0x33, 0xcc, 0x48, 0x41, 0x64,
	0x01, 0x13, 0xd0, 0xa4, 0x83, 0xc2, 0x68, 0x4e, 0x5a, 0xd3, 0xde, 0xfe, 0x40, 0x0a, 0xd6, 0x1e,
	0xff, 0x87, 0x61, 0xb4, 0xc6, 0x39, 0x8e, 0x4a, 0x92, 0x87, 0x34, 0xc1, 0xab, 0xaa, 0xb2, 0x2e,
	0x27, 0x4b, 0x18, 0x49, 0x52, 0x46, 0x23, 0xa3, 0x2d, 0x22, 0xbb, 0xd0, 0x97, 0x64, 0x21, 0x4b,
	0x4b, 0x62, 0x28, 0x3c, 0x6a, 0xfe, 0x6a, 0x80, 0x72, 0x8c, 0xd9, 0x15, 0x7d, 0x5c, 0x5e, 0x36,
	0xe4, 0xa1, 0x7c, 0xdd, 0xb2, 0xed, 0x02, 0x5b, 0x8f, 0x16, 0x68, 0x80, 0x5e, 0xab, 0x3e, 0x5d,
	0xcf, 0x9a, 0xb2, 0xb2, 0xaa, 0x87, 0xe3, 0xa5, 0xe6, 0x3d, 0xbe, 0x53, 0xe3, 0xeb, 0x8c, 0xc0,
	0xab, 0x22, 0xfa, 0x02, 0xf6, 0xa2, 0x34, 0xc9, 0x52, 0x46, 0x58, 0x19, 0x16, 0x9b, 0x8b, 0x2b,
	0x12, 0x95, 0x21, 0x5d, 0x16, 0x86, 0x36, 0x69, 0x4d, 0x15, 0xf3, 0x67, 0x1b, 0x94, 0xb3, 0x34,
	0xc2, 0x17, 0xff, 0xc8, 0xde, 0x18, 0x46, 0xb5, 0x09, 0xf2, 0x35, 0x8b, 0x31, 0xc3, 0x25, 0x4d,
	0x99, 0x74, 0x38, 0x86, 0x51, 0x5d, 0xf1, 0x76, 0xb2, 0x32, 0x3a, 0x85, 0x6e, 0x41, 0x58, 0x49,
	0x58, 0x44, 0x0a, 0xa3, 0x23, 0xc8, 0xf7, 0x24, 0xb9, 0x28, 0x78, 0x16, 0xc8, 0xec, 0xd3, 0x16,
	0x55, 0x6e, 0x11, 0xbd, 0x85, 0x41, 0x86, 0xf3, 0x32, 0x4c, 0x2f, 0xc3, 0x22, 0x23, 0x24, 0x5a,
	0x1b, 0x9a, 0x98, 0xcd, 0x67, 0x7f, 0xb0, 0xcd, 0x71, 0x5e, 0x7a, 0x97, 0x81, 0x00, 0x3c, 0x7f,
	0x03, 0xda, 0x1d, 0xfb, 0xdf, 0x7d, 0x19, 0x82, 0x4a, 0xd8, 0x2a, 0xa6, 0xc5, 0x5a, 0xcc, 0x7c,
	0xd7, 0xfc, 0xde, 0x84, 0xfe, 0xf6, 0x7d, 0xa4, 0x41, 0xdb, 0xf5, 0x16, 0x6e, 0x35, 0xd7, 0xee,
	0xe2, 0xc4, 0xf6, 0xad, 0x4f, 0x7a, 0x13, 0xed, 0xc1, 0x7f, 0x8e, 0x7b, 0xea, 0x5b, 0x6e, 0xe0,
	0x9c, 0x3a, 0x67, 0x76, 0x78, 0x66, 0xfb, 0xef, 0xf4, 0x16, 0xd2, 0xa1, 0xef, 0x1c, 0x7c, 0x70,
	0x0e, 0x2d, 0xb7, 0x8a, 0xb4, 0xd1, 0x08, 0x86, 0x0f, 0x61, 0x0a, 0x87, 0xb9, 0x5e, 0x68, 0x1d,
	0x7e, 0xb4, 0x0f, 0x78, 0x58, 0xef, 0xa0, 0x01, 0xc0, 0x7b, 0xef, 0xee, 0x9a, 0x2a, 0x10, 0xd6,
	0x16, 0x42, 0x43, 0x43, 0xe8, 0x39, 0x5b, 0x81, 0x2e, 0x5f, 0xad, 0x60, 0x71, 0x74, 0xe4, 0x9c,
	0xeb, 0xc0, 0xcf, 0xd6, 0xa1, 0xb8, 0xda, 0x43, 0x3b, 0xd0, 0x0d, 0x16, 0xfe, 0xa2, 0x62, 0xea,
	0xf3, 0xd4, 0xdc, 0xb7, 0x39, 0x6c, 0x87, 0x73, 0xcc, 0x7d, 0x6f, 0x6e, 0xfb, 0xa1, 0xf0, 0x34,
	0xe0, 0xb2, 0xf6, 0xf9, 0xdc, 0xb7, 0x83, 0xc0, 0xf1, 0x5c, 0x7d, 0xc8, 0xef, 0xde, 0x4b, 0xe8,
	0xe6, 0x8f, 0x06, 0xa8, 0x41, 0xf5, 0x0a, 0x08, 0xa0, 0x49, 0x97, 0xa2, 0x6d, 0x0a, 0xda, 0x01,
	0x25, 0x26, 0x37, 0x24, 0x16, 0x4d, 0x53, 0x50, 0x1f, 0xda, 0x45, 0xbc, 0x59, 0xc9, 0x75, 0xdc,
	0x85, 0xfe, 0x32, 0x8d, 0x36, 0x09, 0x7f, 0xc2, 0x4d, 0x1e, 0xcb, 0x01, 0x79, 0x09, 0x6a, 0x5e,
	0x2d, 0xbf, 0x18, 0x8a, 0xad, 0x01, 0x94, 0x7f, 0x09, 0x63, 0x50, 0xae, 0xf9, 0x72, 0x8a, 0x15,
	0xe8, 0xed, 0xf7, 0x65, 0xba, 0x5a, 0xd8, 0x31, 0x28, 0x37, 0xfc, 0x6d, 0xc5, 0x26, 0xdc, 0x27,
	0xc5, 0x7b, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x38, 0x07, 0xa1, 0x1f, 0x05, 0x00, 0x00,
}
